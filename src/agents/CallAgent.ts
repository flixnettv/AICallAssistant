import { BaseAgent, AgentTask } from './MasterAgent';
import { callService } from '../services/callService';
import { aiService } from '../services/aiService';
import { databaseService } from '../services/databaseService';
import { CallLog, Contact, AICall } from '../types';

// Call Agent Implementation
class CallAgent extends BaseAgent {
  private callQueue: Map<string, CallTask> = new Map();
  private activeCalls: Map<string, CallLog> = new Map();
  private callHistory: CallLog[] = [];
  private blockedNumbers: Set<string> = new Set();
  
  constructor() {
    super('call', 'Call Management Agent');
  }
  
  async start(): Promise<void> {
    try {
      console.log('üìû Starting Call Agent...');
      
      this.status = 'initializing';
      
      // Load blocked numbers
      await this.loadBlockedNumbers();
      
      // Load call history
      await this.loadCallHistory();
      
      // Start call monitoring
      this.startCallMonitoring();
      
      this.status = 'running';
      console.log('‚úÖ Call Agent started successfully');
      
    } catch (error) {
      console.error('‚ùå Call Agent start error:', error);
      this.status = 'error';
      throw error;
    }
  }
  
  async stop(): Promise<void> {
    try {
      console.log('üìû Stopping Call Agent...');
      
      this.status = 'stopped';
      
      // End all active calls
      for (const [callId, callLog] of this.activeCalls) {
        await this.endCall(callId);
      }
      
      // Clear call queue
      this.callQueue.clear();
      
      console.log('‚úÖ Call Agent stopped successfully');
      
    } catch (error) {
      console.error('‚ùå Call Agent stop error:', error);
      throw error;
    }
  }
  
  async executeTask(task: AgentTask): Promise<any> {
    try {
      console.log(`üìû Call Agent executing task: ${task.description}`);
      
      this.activeTasks.add(task.id);
      
      let result: any;
      
      switch (task.data.action) {
        case 'makeCall':
          result = await this.makeCall(task.data.phoneNumber, task.data.contactName);
          break;
          
        case 'answerCall':
          result = await this.answerCall(task.data.phoneNumber, task.data.contactName);
          break;
          
        case 'endCall':
          result = await this.endCall(task.data.phoneNumber, task.data.duration);
          break;
          
        case 'makeAICall':
          result = await this.makeAICall(
            task.data.phoneNumber,
            task.data.contactName,
            task.data.voice,
            task.data.reason,
            task.data.isImmediate
          );
          break;
          
        case 'scheduleAICall':
          result = await this.scheduleAICall(
            task.data.phoneNumber,
            task.data.contactName,
            task.data.voice,
            task.data.reason,
            task.data.scheduledTime
          );
          break;
          
        case 'startAIReply':
          result = await this.startAIReply(
            task.data.phoneNumber,
            task.data.contactName,
            task.data.voice,
            task.data.isIncomingCall
          );
          break;
          
        case 'stopAIReply':
          result = await this.stopAIReply(task.data.phoneNumber, task.data.contactName);
          break;
          
        case 'rejectCall':
          result = await this.rejectCall(task.data.phoneNumber, task.data.contactName);
          break;
          
        case 'recordCall':
          result = await this.recordCall(task.data.phoneNumber);
          break;
          
        case 'blockNumber':
          result = await this.blockNumber(task.data.phoneNumber, task.data.reason);
          break;
          
        case 'reportSpam':
          result = await this.reportSpam(task.data.phoneNumber, task.data.reason);
          break;
          
        case 'lookupCallerID':
          result = await this.lookupCallerID(task.data.phoneNumber);
          break;
          
        default:
          throw new Error(`Unknown call action: ${task.data.action}`);
      }
      
      this.taskCompleted();
      this.activeTasks.delete(task.id);
      
      console.log(`‚úÖ Call Agent task completed: ${task.description}`);
      return result;
      
    } catch (error) {
      console.error(`‚ùå Call Agent task error: ${task.description}`, error);
      this.taskError();
      this.activeTasks.delete(task.id);
      throw error;
    }
  }
  
  async cancelTask(taskId: string): Promise<boolean> {
    try {
      const callTask = this.callQueue.get(taskId);
      if (callTask) {
        // Cancel the call task
        await this.cancelCallTask(callTask);
        this.callQueue.delete(taskId);
        return true;
      }
      
      return false;
      
    } catch (error) {
      console.error('‚ùå Cancel call task error:', error);
      return false;
    }
  }
  
  // Call Management Methods
  private async makeCall(phoneNumber: string, reason?: string): Promise<boolean> {
    try {
      // Check if number is blocked
      if (this.blockedNumbers.has(phoneNumber)) {
        throw new Error('Cannot call blocked number');
      }
      
      // Process with AI if reason provided
      if (reason) {
        const aiResult = await aiService.processOutgoingCall(phoneNumber, reason);
        if (!aiResult.success) {
          throw new Error(aiResult.message);
        }
      }
      
      // Make the call
      const success = await callService.makeCall(phoneNumber, reason);
      
      if (success) {
        // Get current call and add to active calls
        const currentCall = callService.getCurrentCall();
        if (currentCall) {
          this.activeCalls.set(currentCall.id, currentCall);
        }
      }
      
      return success;
      
    } catch (error) {
      console.error('‚ùå Make call error:', error);
      throw error;
    }
  }
  
  private async answerCall(phoneNumber: string): Promise<boolean> {
    try {
      // Answer the call
      const success = await callService.answerCall(phoneNumber);
      
      if (success) {
        // Get current call and add to active calls
        const currentCall = callService.getCurrentCall();
        if (currentCall) {
          this.activeCalls.set(currentCall.id, currentCall);
        }
      }
      
      return success;
      
    } catch (error) {
      console.error('‚ùå Answer call error:', error);
      throw error;
    }
  }
  
  private async endCall(callId: string): Promise<boolean> {
    try {
      // End the call
      const success = await callService.endCall();
      
      if (success) {
        // Remove from active calls
        this.activeCalls.delete(callId);
        
        // Update call history
        const callLog = await this.getCallLogById(callId);
        if (callLog) {
          this.callHistory.push(callLog);
        }
      }
      
      return success;
      
    } catch (error) {
      console.error('‚ùå End call error:', error);
      throw error;
    }
  }
  
  // AI Call Methods
  private async initiateAICall(phoneNumber: string, reason: string, voice: string): Promise<boolean> {
    try {
      // Validate reason
      if (!reason.trim()) {
        throw new Error('Call reason is required for AI calls');
      }
      
      // Get AI voice
      const voices = await aiService.getAvailableVoices();
      const selectedVoice = voices.find(v => v.id === voice);
      
      if (!selectedVoice) {
        throw new Error('Selected voice not found');
      }
      
      // Start AI conversation
      await aiService.startConversation(reason, selectedVoice);
      
      // Create AI call log
      const callLog: Omit<CallLog, 'id'> = {
        contactId: undefined,
        phoneNumber,
        callType: 'ai-outgoing',
        duration: 0,
        timestamp: new Date(),
        isRecorded: false,
        callReason: reason,
        spamScore: 0,
      };
      
      const newCallLog = await databaseService.createCallLog(callLog);
      this.activeCalls.set(newCallLog.id, newCallLog);
      
      console.log('‚úÖ AI call initiated successfully');
      return true;
      
    } catch (error) {
      console.error('‚ùå Initiate AI call error:', error);
      throw error;
    }
  }
  
  private async scheduleAICall(phoneNumber: string, reason: string, voice: string, scheduledTime: Date): Promise<boolean> {
    try {
      // Validate scheduled time
      if (scheduledTime <= new Date()) {
        throw new Error('Scheduled time must be in the future');
      }
      
      // Create scheduled call record
      const scheduledCall: AICall = {
        id: Date.now().toString(),
        phoneNumber,
        reason,
        voice,
        scheduledTime,
        status: 'scheduled',
        createdAt: new Date(),
      };
      
      // Store in database
      // TODO: Implement scheduled calls storage
      
      console.log('‚úÖ AI call scheduled successfully');
      return true;
      
    } catch (error) {
      console.error('‚ùå Schedule AI call error:', error);
      throw error;
    }
  }
  
  private async aiAnswerCall(phoneNumber: string, voice: string): Promise<boolean> {
    try {
      // Get AI voice
      const voices = await aiService.getAvailableVoices();
      const selectedVoice = voices.find(v => v.id === voice);
      
      if (!selectedVoice) {
        throw new Error('Selected voice not found');
      }
      
      // Start AI conversation for incoming call
      const context = `Incoming call from ${phoneNumber}. You are answering this call on behalf of the user.`;
      await aiService.startConversation(context, selectedVoice);
      
      // Create call log
      const callLog: Omit<CallLog, 'id'> = {
        contactId: undefined,
        phoneNumber,
        callType: 'ai-incoming',
        duration: 0,
        timestamp: new Date(),
        isRecorded: false,
        spamScore: 0,
      };
      
      const newCallLog = await databaseService.createCallLog(callLog);
      this.activeCalls.set(newCallLog.id, newCallLog);
      
      console.log('‚úÖ AI call answered successfully');
      return true;
      
    } catch (error) {
      console.error('‚ùå AI answer call error:', error);
      throw error;
    }
  }
  
  // Recording Methods
  private async startRecording(callId: string): Promise<boolean> {
    try {
      const callLog = this.activeCalls.get(callId);
      if (!callLog) {
        throw new Error('Call not found');
      }
      
      const success = await callService.startRecording();
      return success;
      
    } catch (error) {
      console.error('‚ùå Start recording error:', error);
      throw error;
    }
  }
  
  private async stopRecording(callId: string): Promise<string | null> {
    try {
      const callLog = this.activeCalls.get(callId);
      if (!callLog) {
        throw new Error('Call not found');
      }
      
      const recordingPath = await callService.stopRecording();
      return recordingPath;
      
    } catch (error) {
      console.error('‚ùå Stop recording error:', error);
      throw error;
    }
  }
  
  // Security Methods
  private async blockNumber(phoneNumber: string): Promise<boolean> {
    try {
      const success = await callService.blockNumber(phoneNumber);
      
      if (success) {
        this.blockedNumbers.add(phoneNumber);
        await this.saveBlockedNumbers();
      }
      
      return success;
      
    } catch (error) {
      console.error('‚ùå Block number error:', error);
      throw error;
    }
  }
  
  private async unblockNumber(phoneNumber: string): Promise<boolean> {
    try {
      const success = await callService.unblockNumber(phoneNumber);
      
      if (success) {
        this.blockedNumbers.delete(phoneNumber);
        await this.saveBlockedNumbers();
      }
      
      return success;
      
    } catch (error) {
      console.error('‚ùå Unblock number error:', error);
      throw error;
    }
  }
  
  private async reportSpam(phoneNumber: string, reason: string): Promise<boolean> {
    try {
      const success = await callService.reportSpam(phoneNumber, reason);
      return success;
      
    } catch (error) {
      console.error('‚ùå Report spam error:', error);
      throw error;
    }
  }
  
  // Caller ID Methods
  private async lookupCaller(phoneNumber: string): Promise<any> {
    try {
      const callerInfo = await callService.lookupCaller(phoneNumber);
      return callerInfo;
      
    } catch (error) {
      console.error('‚ùå Lookup caller error:', error);
      throw error;
    }
  }
  
  // Private helper methods
  private async loadBlockedNumbers(): Promise<void> {
    try {
      // Load from storage or database
      // For now, using empty set
      this.blockedNumbers = new Set();
    } catch (error) {
      console.error('‚ùå Load blocked numbers error:', error);
    }
  }
  
  private async saveBlockedNumbers(): Promise<void> {
    try {
      // Save to storage or database
      // For now, just logging
      console.log('üíæ Blocked numbers saved');
    } catch (error) {
      console.error('‚ùå Save blocked numbers error:', error);
    }
  }
  
  private async loadCallHistory(): Promise<void> {
    try {
      this.callHistory = await callService.getCallHistory(100);
    } catch (error) {
      console.error('‚ùå Load call history error:', error);
      this.callHistory = [];
    }
  }
  
  private startCallMonitoring(): void {
    // Monitor active calls for issues
    setInterval(() => {
      try {
        for (const [callId, callLog] of this.activeCalls) {
          // Check call duration
          const duration = Math.floor((Date.now() - callLog.timestamp.getTime()) / 1000);
          
          // Alert if call is too long
          if (duration > 3600) { // 1 hour
            console.log(`‚ö†Ô∏è Long call detected: ${callId} (${duration}s)`);
          }
        }
      } catch (error) {
        console.error('‚ùå Call monitoring error:', error);
      }
    }, 30000); // Check every 30 seconds
  }
  
  private async getCallLogById(callId: string): Promise<CallLog | null> {
    try {
      // Get from database
      const callLogs = await databaseService.getCallLogs();
      return callLogs.find(log => log.id === callId) || null;
    } catch (error) {
      console.error('‚ùå Get call log by ID error:', error);
      return null;
    }
  }
  
  private async cancelCallTask(callTask: CallTask): Promise<void> {
    try {
      // Cancel the specific call task
      if (callTask.callId) {
        await this.endCall(callTask.callId);
      }
    } catch (error) {
      console.error('‚ùå Cancel call task error:', error);
    }
  }

  // ÿßŸÑŸÖŸÉÿßŸÑŸÖÿßÿ™ ÿ®ÿßŸÑÿ∞ŸÉÿßÿ° ÿßŸÑÿßÿµÿ∑ŸÜÿßÿπŸä
  private async makeAICall(
    phoneNumber: string,
    contactName?: string,
    voice?: AIVoice,
    reason?: string,
    isImmediate: boolean = true
  ): Promise<{
    success: boolean;
    callId: string;
    message: string;
    aiContext: any;
  }> {
    try {
      console.log(`ü§ñ Making AI call to ${phoneNumber} with voice: ${voice?.name}`);

      // ÿ•ŸÜÿ¥ÿßÿ° ŸÖÿπÿ±ŸÅ ŸÅÿ±ŸäÿØ ŸÑŸÑŸÖŸÉÿßŸÑŸÖÿ©
      const callId = `ai_call_${Date.now()}`;

      // ÿ•ÿπÿØÿßÿØ ÿ≥ŸäÿßŸÇ ÿßŸÑÿ∞ŸÉÿßÿ° ÿßŸÑÿßÿµÿ∑ŸÜÿßÿπŸä
      const aiContext = {
        callId,
        phoneNumber,
        contactName,
        reason: reason || 'ŸÖŸÉÿßŸÑŸÖÿ© ÿπÿßŸÖÿ©',
        voice: voice || this.getDefaultVoice(),
        dialect: 'egyptian',
        language: 'ar-EG',
        timestamp: new Date(),
        isImmediate,
      };

      if (isImmediate) {
        // ÿ•ÿ¨ÿ±ÿßÿ° ÿßŸÑŸÖŸÉÿßŸÑŸÖÿ© ŸÅŸàÿ±ÿßŸã
        await this.initiateAICall(aiContext);
      }

      // ÿ™ÿ≥ÿ¨ŸäŸÑ ÿßŸÑŸÖŸÉÿßŸÑŸÖÿ© ŸÅŸä ŸÇÿßÿπÿØÿ© ÿßŸÑÿ®ŸäÿßŸÜÿßÿ™
      await this.logAICall(aiContext);

      return {
        success: true,
        callId,
        message: 'ÿ™ŸÖ ÿ®ÿØÿ° ÿßŸÑŸÖŸÉÿßŸÑŸÖÿ© ÿ®ÿßŸÑÿ∞ŸÉÿßÿ° ÿßŸÑÿßÿµÿ∑ŸÜÿßÿπŸä ÿ®ŸÜÿ¨ÿßÿ≠',
        aiContext,
      };

    } catch (error) {
      console.error('‚ùå Make AI call error:', error);
      throw error;
    }
  }

  private async scheduleAICall(
    phoneNumber: string,
    contactName?: string,
    voice?: AIVoice,
    reason?: string,
    scheduledTime: Date
  ): Promise<{
    success: boolean;
    scheduleId: string;
    message: string;
    scheduledFor: Date;
  }> {
    try {
      console.log(`üìÖ Scheduling AI call to ${phoneNumber} for ${scheduledTime}`);

      const scheduleId = `ai_schedule_${Date.now()}`;

      // ÿ•ŸÜÿ¥ÿßÿ° ŸÖŸáŸÖÿ© ŸÖÿ¨ÿØŸàŸÑÿ©
      const scheduledTask = {
        id: scheduleId,
        type: 'ai_call_scheduled',
        priority: 'medium',
        description: `ŸÖŸÉÿßŸÑŸÖÿ© ŸÖÿ¨ÿØŸàŸÑÿ© ÿ®ÿßŸÑÿ∞ŸÉÿßÿ° ÿßŸÑÿßÿµÿ∑ŸÜÿßÿπŸä ÿ•ŸÑŸâ ${contactName || phoneNumber}`,
        data: {
          action: 'executeScheduledAICall',
          phoneNumber,
          contactName,
          voice: voice || this.getDefaultVoice(),
          reason: reason || 'ŸÖŸÉÿßŸÑŸÖÿ© ŸÖÿ¨ÿØŸàŸÑÿ©',
          scheduledTime,
        },
        status: 'pending',
        createdAt: new Date(),
        scheduledFor: scheduledTime,
      };

      // ÿ•ÿ∂ÿßŸÅÿ© ÿßŸÑŸÖŸáŸÖÿ© ÿ•ŸÑŸâ ŸÇÿßÿ¶ŸÖÿ© ÿßŸÑŸÖŸáÿßŸÖ ÿßŸÑŸÖÿ¨ÿØŸàŸÑÿ©
      this.scheduledCalls.set(scheduleId, scheduledTask);

      // ÿ¨ÿØŸàŸÑÿ© ÿßŸÑÿ™ŸÜŸÅŸäÿ∞
      const timeUntilExecution = scheduledTime.getTime() - Date.now();
      if (timeUntilExecution > 0) {
        setTimeout(async () => {
          await this.executeScheduledAICall(scheduledTask);
        }, timeUntilExecution);
      }

      return {
        success: true,
        scheduleId,
        message: 'ÿ™ŸÖ ÿ¨ÿØŸàŸÑÿ© ÿßŸÑŸÖŸÉÿßŸÑŸÖÿ© ÿ®ÿßŸÑÿ∞ŸÉÿßÿ° ÿßŸÑÿßÿµÿ∑ŸÜÿßÿπŸä ÿ®ŸÜÿ¨ÿßÿ≠',
        scheduledFor: scheduledTime,
      };

    } catch (error) {
      console.error('‚ùå Schedule AI call error:', error);
      throw error;
    }
  }

  private async executeScheduledAICall(scheduledTask: any): Promise<void> {
    try {
      console.log(`‚è∞ Executing scheduled AI call: ${scheduledTask.id}`);

      // ÿ™ÿ≠ÿØŸäÿ´ ÿ≠ÿßŸÑÿ© ÿßŸÑŸÖŸáŸÖÿ©
      scheduledTask.status = 'running';

      // ÿ™ŸÜŸÅŸäÿ∞ ÿßŸÑŸÖŸÉÿßŸÑŸÖÿ©
      await this.makeAICall(
        scheduledTask.data.phoneNumber,
        scheduledTask.data.contactName,
        scheduledTask.data.voice,
        scheduledTask.data.reason,
        true
      );

      // ÿ™ÿ≠ÿØŸäÿ´ ÿ≠ÿßŸÑÿ© ÿßŸÑŸÖŸáŸÖÿ©
      scheduledTask.status = 'completed';
      scheduledTask.completedAt = new Date();

      // ÿ•ÿ≤ÿßŸÑÿ© ŸÖŸÜ ÿßŸÑŸÇÿßÿ¶ŸÖÿ© ÿßŸÑŸÖÿ¨ÿØŸàŸÑÿ©
      this.scheduledCalls.delete(scheduledTask.id);

    } catch (error) {
      console.error('‚ùå Execute scheduled AI call error:', error);
      scheduledTask.status = 'failed';
      scheduledTask.error = error.message;
    }
  }

  private async initiateAICall(aiContext: any): Promise<void> {
    try {
      // ÿ•ÿπÿØÿßÿØ ÿßŸÑÿ∞ŸÉÿßÿ° ÿßŸÑÿßÿµÿ∑ŸÜÿßÿπŸä ŸÑŸÑŸÖŸÉÿßŸÑŸÖÿ©
      await this.setupAIConversation(aiContext);

      // ÿ®ÿØÿ° ÿßŸÑŸÖŸÉÿßŸÑŸÖÿ©
      const callResult = await this.startCall(aiContext.phoneNumber);

      if (callResult.success) {
        // ÿ®ÿØÿ° ÿßŸÑŸÖÿ≠ÿßÿØÿ´ÿ© ÿ®ÿßŸÑÿ∞ŸÉÿßÿ° ÿßŸÑÿßÿµÿ∑ŸÜÿßÿπŸä
        await this.startAIConversation(aiContext);
      }

    } catch (error) {
      console.error('‚ùå Initiate AI call error:', error);
      throw error;
    }
  }

  private async setupAIConversation(aiContext: any): Promise<void> {
    try {
      // ÿ•ÿπÿØÿßÿØ ÿ≥ŸäÿßŸÇ ÿßŸÑŸÖÿ≠ÿßÿØÿ´ÿ© ÿ®ÿßŸÑŸÑŸáÿ¨ÿ© ÿßŸÑŸÖÿµÿ±Ÿäÿ©
      const conversationContext = {
        language: 'ar-EG',
        dialect: 'egyptian',
        voice: aiContext.voice,
        callReason: aiContext.reason,
        contactName: aiContext.contactName,
        greeting: this.generateEgyptianGreeting(aiContext.voice, aiContext.contactName),
        conversationFlow: this.generateConversationFlow(aiContext.reason),
      };

      // ÿ≠ŸÅÿ∏ ÿ≥ŸäÿßŸÇ ÿßŸÑŸÖÿ≠ÿßÿØÿ´ÿ©
      this.activeAIConversations.set(aiContext.callId, {
        ...aiContext,
        conversationContext,
        status: 'active',
        startTime: new Date(),
      });

    } catch (error) {
      console.error('‚ùå Setup AI conversation error:', error);
      throw error;
    }
  }

  private async startAIConversation(aiContext: any): Promise<void> {
    try {
      const conversation = this.activeAIConversations.get(aiContext.callId);
      if (!conversation) {
        throw new Error('Conversation not found');
      }

      // ÿ®ÿØÿ° ÿßŸÑŸÖÿ≠ÿßÿØÿ´ÿ© ŸÖÿπ ÿßŸÑÿ∞ŸÉÿßÿ° ÿßŸÑÿßÿµÿ∑ŸÜÿßÿπŸä
      const aiTask = {
        id: Date.now().toString(),
        type: 'ai_conversation',
        priority: 'high',
        description: 'ÿ®ÿØÿ° ŸÖÿ≠ÿßÿØÿ´ÿ© ÿ®ÿßŸÑÿ∞ŸÉÿßÿ° ÿßŸÑÿßÿµÿ∑ŸÜÿßÿπŸä',
        data: {
          action: 'startConversation',
          context: conversation.conversationContext,
          voice: aiContext.voice,
        },
        status: 'pending',
        createdAt: new Date(),
      };

      await aiAgent.executeTask(aiTask);

      console.log(`‚úÖ AI conversation started for call: ${aiContext.callId}`);

    } catch (error) {
      console.error('‚ùå Start AI conversation error:', error);
      throw error;
    }
  }

  // ÿßŸÑÿ±ÿØ ÿπŸÑŸâ ÿßŸÑŸÖŸÉÿßŸÑŸÖÿßÿ™ ÿßŸÑŸàÿßÿ±ÿØÿ© ÿ®ÿßŸÑÿ∞ŸÉÿßÿ° ÿßŸÑÿßÿµÿ∑ŸÜÿßÿπŸä
  private async startAIReply(
    phoneNumber: string,
    contactName?: string,
    voice?: AIVoice,
    isIncomingCall: boolean = true
  ): Promise<{
    success: boolean;
    replyId: string;
    message: string;
    aiContext: any;
  }> {
    try {
      console.log(`ü§ñ Starting AI reply for incoming call from ${phoneNumber}`);

      const replyId = `ai_reply_${Date.now()}`;

      // ÿ•ÿπÿØÿßÿØ ÿ≥ŸäÿßŸÇ ÿßŸÑÿ±ÿØ
      const aiContext = {
        replyId,
        phoneNumber,
        contactName,
        voice: voice || this.getDefaultVoice(),
        dialect: 'egyptian',
        language: 'ar-EG',
        isIncomingCall,
        timestamp: new Date(),
        greeting: this.generateEgyptianGreeting(voice, contactName, true),
        replyStrategy: this.generateReplyStrategy(contactName),
      };

      // ÿ®ÿØÿ° ÿßŸÑÿ±ÿØ ÿ®ÿßŸÑÿ∞ŸÉÿßÿ° ÿßŸÑÿßÿµÿ∑ŸÜÿßÿπŸä
      await this.initiateAIReply(aiContext);

      // ÿ™ÿ≥ÿ¨ŸäŸÑ ÿßŸÑÿ±ÿØ
      await this.logAIReply(aiContext);

      return {
        success: true,
        replyId,
        message: 'ÿ™ŸÖ ÿ®ÿØÿ° ÿßŸÑÿ±ÿØ ÿ®ÿßŸÑÿ∞ŸÉÿßÿ° ÿßŸÑÿßÿµÿ∑ŸÜÿßÿπŸä ÿ®ŸÜÿ¨ÿßÿ≠',
        aiContext,
      };

    } catch (error) {
      console.error('‚ùå Start AI reply error:', error);
      throw error;
    }
  }

  private async stopAIReply(
    phoneNumber: string,
    contactName?: string
  ): Promise<{
    success: boolean;
    message: string;
    duration: number;
  }> {
    try {
      console.log(`üõë Stopping AI reply for ${phoneNumber}`);

      // ÿßŸÑÿ®ÿ≠ÿ´ ÿπŸÜ ÿßŸÑŸÖÿ≠ÿßÿØÿ´ÿ© ÿßŸÑŸÜÿ¥ÿ∑ÿ©
      let activeConversation: any = null;
      for (const [id, conversation] of this.activeAIConversations) {
        if (conversation.phoneNumber === phoneNumber && conversation.status === 'active') {
          activeConversation = conversation;
          break;
        }
      }

      if (!activeConversation) {
        throw new Error('No active AI conversation found');
      }

      // ÿ•ŸäŸÇÿßŸÅ ÿßŸÑŸÖÿ≠ÿßÿØÿ´ÿ©
      const stopTask = {
        id: Date.now().toString(),
        type: 'ai_conversation_stop',
        priority: 'high',
        description: 'ÿ•ŸäŸÇÿßŸÅ ŸÖÿ≠ÿßÿØÿ´ÿ© ÿßŸÑÿ∞ŸÉÿßÿ° ÿßŸÑÿßÿµÿ∑ŸÜÿßÿπŸä',
        data: {
          action: 'stopConversation',
          conversationId: activeConversation.callId || activeConversation.replyId,
        },
        status: 'pending',
        createdAt: new Date(),
      };

      await aiAgent.executeTask(stopTask);

      // ÿ™ÿ≠ÿØŸäÿ´ ÿ≠ÿßŸÑÿ© ÿßŸÑŸÖÿ≠ÿßÿØÿ´ÿ©
      activeConversation.status = 'stopped';
      activeConversation.endTime = new Date();
      activeConversation.duration = activeConversation.endTime.getTime() - activeConversation.startTime.getTime();

      return {
        success: true,
        message: 'ÿ™ŸÖ ÿ•ŸäŸÇÿßŸÅ ÿßŸÑÿ±ÿØ ÿ®ÿßŸÑÿ∞ŸÉÿßÿ° ÿßŸÑÿßÿµÿ∑ŸÜÿßÿπŸä ÿ®ŸÜÿ¨ÿßÿ≠',
        duration: activeConversation.duration,
      };

    } catch (error) {
      console.error('‚ùå Stop AI reply error:', error);
      throw error;
    }
  }

  private async initiateAIReply(aiContext: any): Promise<void> {
    try {
      // ÿ•ÿπÿØÿßÿØ ÿ≥ŸäÿßŸÇ ÿßŸÑÿ±ÿØ
      const replyContext = {
        language: 'ar-EG',
        dialect: 'egyptian',
        voice: aiContext.voice,
        greeting: aiContext.greeting,
        replyStrategy: aiContext.replyStrategy,
        isIncomingCall: aiContext.isIncomingCall,
      };

      // ÿ≠ŸÅÿ∏ ÿ≥ŸäÿßŸÇ ÿßŸÑÿ±ÿØ
      this.activeAIConversations.set(aiContext.replyId, {
        ...aiContext,
        replyContext,
        status: 'active',
        startTime: new Date(),
      });

      // ÿ®ÿØÿ° ÿßŸÑŸÖÿ≠ÿßÿØÿ´ÿ©
      await this.startAIConversation(aiContext);

    } catch (error) {
      console.error('‚ùå Initiate AI reply error:', error);
      throw error;
    }
  }

  // ÿ™ŸàŸÑŸäÿØ ÿßŸÑÿ™ÿ≠Ÿäÿßÿ™ ÿ®ÿßŸÑŸÑŸáÿ¨ÿ© ÿßŸÑŸÖÿµÿ±Ÿäÿ©
  private generateEgyptianGreeting(voice?: AIVoice, contactName?: string, isReply: boolean = false): string {
    const greetings = {
      male: {
        young: isReply ? 'ÿ£ŸáŸÑÿßŸã Ÿàÿ≥ŸáŸÑÿßŸãÿå ÿ•ÿ≤ŸäŸÉÿü' : 'ÿ£ŸáŸÑÿßŸã Ÿàÿ≥ŸáŸÑÿßŸãÿå ÿ•ÿ≤ŸäŸÉÿü',
        elder: isReply ? 'ÿ£ŸáŸÑÿßŸã Ÿàÿ≥ŸáŸÑÿßŸãÿå ÿ•ÿ≤ŸäŸÉ Ÿäÿß ŸÅŸÜÿØŸÖÿü' : 'ÿ£ŸáŸÑÿßŸã Ÿàÿ≥ŸáŸÑÿßŸãÿå ÿ•ÿ≤ŸäŸÉ Ÿäÿß ŸÅŸÜÿØŸÖÿü',
        child: isReply ? 'ÿ£ŸáŸÑÿßŸã Ÿàÿ≥ŸáŸÑÿßŸãÿå ÿ•ÿ≤ŸäŸÉ Ÿäÿß ÿ≠ÿ®Ÿäÿ®Ÿäÿü' : 'ÿ£ŸáŸÑÿßŸã Ÿàÿ≥ŸáŸÑÿßŸãÿå ÿ•ÿ≤ŸäŸÉ Ÿäÿß ÿ≠ÿ®Ÿäÿ®Ÿäÿü',
      },
      female: {
        young: isReply ? 'ÿ£ŸáŸÑÿßŸã Ÿàÿ≥ŸáŸÑÿßŸãÿå ÿ•ÿ≤ŸäŸÉÿü' : 'ÿ£ŸáŸÑÿßŸã Ÿàÿ≥ŸáŸÑÿßŸãÿå ÿ•ÿ≤ŸäŸÉÿü',
        elder: isReply ? 'ÿ£ŸáŸÑÿßŸã Ÿàÿ≥ŸáŸÑÿßŸãÿå ÿ•ÿ≤ŸäŸÉ Ÿäÿß ŸÅŸÜÿØŸÖÿ©ÿü' : 'ÿ£ŸáŸÑÿßŸã Ÿàÿ≥ŸáŸÑÿßŸãÿå ÿ•ÿ≤ŸäŸÉ Ÿäÿß ŸÅŸÜÿØŸÖÿ©ÿü',
        child: isReply ? 'ÿ£ŸáŸÑÿßŸã Ÿàÿ≥ŸáŸÑÿßŸãÿå ÿ•ÿ≤ŸäŸÉ Ÿäÿß ÿ≠ÿ®Ÿäÿ®ÿ™Ÿäÿü' : 'ÿ£ŸáŸÑÿßŸã Ÿàÿ≥ŸáŸÑÿßŸãÿå ÿ•ÿ≤ŸäŸÉ Ÿäÿß ÿ≠ÿ®Ÿäÿ®ÿ™Ÿäÿü',
      },
    };

    if (contactName) {
      const gender = voice?.gender || 'male';
      const age = voice?.age || 'young';
      const greeting = greetings[gender]?.[age] || greetings.male.young;
      return `${greeting} ÿ£ŸÜÿß ${contactName}`;
    }

    return greetings.male.young;
  }

  // ÿ™ŸàŸÑŸäÿØ ÿßÿ≥ÿ™ÿ±ÿßÿ™Ÿäÿ¨Ÿäÿ© ÿßŸÑŸÖÿ≠ÿßÿØÿ´ÿ©
  private generateConversationFlow(reason?: string): any {
    const flows = {
      default: [
        'greeting',
        'introduction',
        'purpose',
        'conversation',
        'closing',
      ],
      business: [
        'greeting',
        'introduction',
        'business_purpose',
        'discussion',
        'next_steps',
        'closing',
      ],
      personal: [
        'greeting',
        'introduction',
        'personal_purpose',
        'casual_conversation',
        'closing',
      ],
    };

    if (reason?.includes('ÿπŸÖŸÑ') || reason?.includes('business')) {
      return flows.business;
    } else if (reason?.includes('ÿ¥ÿÆÿµŸä') || reason?.includes('personal')) {
      return flows.personal;
    }

    return flows.default;
  }

  // ÿ™ŸàŸÑŸäÿØ ÿßÿ≥ÿ™ÿ±ÿßÿ™Ÿäÿ¨Ÿäÿ© ÿßŸÑÿ±ÿØ
  private generateReplyStrategy(contactName?: string): any {
    return {
      approach: 'friendly',
      tone: 'helpful',
      responseType: 'conversational',
      fallback: 'transfer_to_human',
      customGreeting: contactName ? `ÿ£ŸáŸÑÿßŸã Ÿàÿ≥ŸáŸÑÿßŸã ${contactName}` : 'ÿ£ŸáŸÑÿßŸã Ÿàÿ≥ŸáŸÑÿßŸã',
    };
  }

  // ÿßŸÑÿ≠ÿµŸàŸÑ ÿπŸÑŸâ ÿßŸÑÿµŸàÿ™ ÿßŸÑÿßŸÅÿ™ÿ±ÿßÿ∂Ÿä
  private getDefaultVoice(): AIVoice {
    return {
      id: 'egyptian_male_default',
      name: 'ÿ£ÿ≠ŸÖÿØ - ÿ¥ÿßÿ® ŸÖÿµÿ±Ÿä',
      language: 'ar-EG',
      dialect: 'egyptian',
      gender: 'male',
      age: 'young',
      description: 'ÿµŸàÿ™ ÿ¥ÿßÿ® ŸÖÿµÿ±Ÿä ÿßŸÅÿ™ÿ±ÿßÿ∂Ÿä',
      previewUrl: '',
      isLocal: true,
    };
  }

  // ÿ™ÿ≥ÿ¨ŸäŸÑ ÿßŸÑŸÖŸÉÿßŸÑŸÖÿßÿ™ ÿ®ÿßŸÑÿ∞ŸÉÿßÿ° ÿßŸÑÿßÿµÿ∑ŸÜÿßÿπŸä
  private async logAICall(aiContext: any): Promise<void> {
    try {
      const callLog = {
        id: aiContext.callId,
        phoneNumber: aiContext.phoneNumber,
        contactName: aiContext.contactName,
        type: 'ai_outgoing',
        startTime: aiContext.timestamp,
        duration: 0,
        isAICall: true,
        aiVoice: aiContext.voice.name,
        aiReason: aiContext.reason,
        status: 'initiated',
      };

      await databaseService.addCallLog(callLog);

    } catch (error) {
      console.error('‚ùå Log AI call error:', error);
    }
  }

  // ÿ™ÿ≥ÿ¨ŸäŸÑ ÿßŸÑÿ±ÿØ ÿ®ÿßŸÑÿ∞ŸÉÿßÿ° ÿßŸÑÿßÿµÿ∑ŸÜÿßÿπŸä
  private async logAIReply(aiContext: any): Promise<void> {
    try {
      const replyLog = {
        id: aiContext.replyId,
        phoneNumber: aiContext.phoneNumber,
        contactName: aiContext.contactName,
        type: 'ai_incoming',
        startTime: aiContext.timestamp,
        duration: 0,
        isAIReply: true,
        aiVoice: aiContext.voice.name,
        status: 'active',
      };

      await databaseService.addCallLog(replyLog);

    } catch (error) {
      console.error('‚ùå Log AI reply error:', error);
    }
  }
}

// Call Task Interface
interface CallTask {
  id: string;
  callId?: string;
  phoneNumber: string;
  action: string;
  data: any;
  status: 'pending' | 'running' | 'completed' | 'cancelled';
}

// Export singleton instance
export const callAgent = new CallAgent();

// Export types
export type { CallTask };